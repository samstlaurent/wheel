<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<title>Sporcle of the Day Selector</title>
	<style>
		body {
			font-family: Arial, sans-serif;
			text-align: center;
			background: #f0f0f0;
		}
		canvas {
			margin-top: 20px;
			background: white;
			border-radius: 10px;
			box-shadow: 0 0 10px rgba(0,0,0,0.3);
		}
		#name-list { margin: 20px; }
		.name-item {
			display: inline-flex;
			background: #4CAF50;
			color: white;
			padding: 5px;
			border-radius: 5px;
			margin: 3px;
			cursor: pointer;
			user-select: none;
			font-weight: bold;
		}
		.excluded {
			background: #bbb;
			color: #555;
		}
		#download-btn {
			background: #ff6b6b;
			color: white;
			padding: 10px;
			border: none;
			border-radius: 5px;
			cursor: pointer;
		}
		#download-btn:disabled {
			background: #ccc;
			cursor: default;
		}
	</style>
</head>
<body>

<canvas id="canvas" width="800" height="600"></canvas>
<div id="name-list"></div>
<button id="download-btn" disabled>Download Video</button>

<audio id="wheelTick1" src="https://raw.githubusercontent.com/samstlaurent/wheel/main/wheelTick1.mp3" crossorigin=""></audio>
<audio id="wheelTick2" src="https://raw.githubusercontent.com/samstlaurent/wheel/main/wheelTick2.mp3" crossorigin=""></audio>
<audio id="wheelStop1" src="https://raw.githubusercontent.com/samstlaurent/wheel/main/wheelStop1.mp3" crossorigin=""></audio>
<audio id="wheelStop2" src="https://raw.githubusercontent.com/samstlaurent/wheel/main/wheelStop2.mp3" crossorigin=""></audio>
<audio id="wheelStop3" src="https://raw.githubusercontent.com/samstlaurent/wheel/main/wheelStop3.mp3" crossorigin=""></audio>
<audio id="wheelStop4" src="https://raw.githubusercontent.com/samstlaurent/wheel/main/wheelStop4.mp3" crossorigin=""></audio>
<audio id="wheelStop5" src="https://raw.githubusercontent.com/samstlaurent/wheel/main/wheelStop5.mp3" crossorigin=""></audio>
 
<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const canvasCenterX = canvas.width / 2;
const canvasCenterY = canvas.height / 2;
const wheelRadius = Math.min(canvasCenterX, canvasCenterY) - 50;
const spinButtonRadius = 60;
const names = ["Aaron D", "Aaron E", "Andrea", "Jasmine", "Jayden", "Jonathan", "Josey", "Lauren", "Michelle", "Quintin", "Sam", "Victoria"];
const confettiColors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#6c5ce7', '#a0e7e5', '#ffeaa7', '#fd79a8', '#00b894', '#e17055', '#74b9ff', '#55a3ff', '#fd9644', '#d63031', '#00cec9'];
const sortedNames = [...names].sort((a, b) => a.localeCompare(b));
const wheelStopSoundEffects = [document.getElementById("wheelStop1"), document.getElementById("wheelStop2"), document.getElementById("wheelStop3"), document.getElementById("wheelStop4"), document.getElementById("wheelStop5")];
const wheelTickSoundEffects = [document.getElementById("wheelTick1"), document.getElementById("wheelTick2")];
const wheelTick = wheelTickSoundEffects[Math.floor(Math.random() * wheelTickSoundEffects.length)]

let nameColors = {}, nameIncluded = {}, confetti = [], recordedChunks = [];
let wheelAngle = 0, wheelSpeed = 0, wheelFriction = 0, arrowDeflection = 0, confettiSpawnTime = 0, lastTickTime = 0, lastSliceIndex = -1;
let mediaRecorder = null, winningIndex = null, isRecording = false, spinning = false, confettiActive = false;
let activeSounds = new Set(), audioSources = new WeakMap();

const audioCtx = new AudioContext();
const audioDestination = audioCtx.createMediaStreamDestination();

function playSound(audio) {
  // Reuse or create the MediaElementSource
  let source = audioSources.get(audio);
  if (!source) {
    source = audioCtx.createMediaElementSource(audio);
    source.connect(audioCtx.destination);
    source.connect(audioDestination);
    audioSources.set(audio, source);
  }

  audio.currentTime = 0;

  activeSounds.add(audio);
  audio.onended = () => {
    activeSounds.delete(audio);
  };

  audio.play();
}


function recomputeColors() {
  const includedNames = names.filter(n => nameIncluded[n]);
  const colors = [];
  for (let i = 0; i < includedNames.length; i++) {
    const hue = Math.round((360 * i / includedNames.length) % 360);
    colors.push(`hsl(${hue}, 80%, 60%)`);
  }
  includedNames.forEach((n,i) => nameColors[n] = colors[i]);
}

function setNameControlsDisabled(disabled) {
	document.querySelectorAll("#name-list .name-item").forEach(item => item.style.pointerEvents = disabled ? "none" : "auto");
}

function drawCanvas() {
	// Handle wheel rotation when spinning
	if (spinning) {
		wheelSpeed *= wheelFriction;
		if (wheelSpeed < 0.002) {
			spinning = false;

			if (arrowDeflection !== 0) {
				arrowDeflection *= 0.85;
				if (Math.abs(arrowDeflection) < 0.01) {
					arrowDeflection = 0;
				}
			} else {
				const includedNames = names.filter(n => nameIncluded[n]);
				if (includedNames.length === 0) {
					setNameControlsDisabled(false);
				} else {
					let relativeAngle = (Math.PI * 2 - wheelAngle) % (Math.PI * 2);
					let segmentIndex = Math.floor(relativeAngle * includedNames.length / Math.PI / 2);
					segmentIndex = Math.min(segmentIndex, includedNames.length - 1);

					const winnerName = includedNames[segmentIndex];
					winningIndex = names.indexOf(winnerName);

					// play sound, confetti, etc.
					let random_number = Math.random();
					let wheelStopSound = wheelStopSoundEffects[Math.floor(Math.random() * wheelStopSoundEffects.length)];
					playSound(wheelStopSound);

					setNameControlsDisabled(false);
					confettiActive = true;
					confetti = [];
					confettiSpawnTime = 0;
				}
			}
		} else {

			wheelAngle = (wheelAngle + wheelSpeed) % (Math.PI * 2);

			// Check for slice boundary crossing and deflect arrow + play sound
			const includedNames = names.filter(n => nameIncluded[n]);
			if (includedNames.length > 0) {
				const arc = (Math.PI * 2) / includedNames.length;
				let relativeAngle = (Math.PI * 2 - wheelAngle) % (Math.PI * 2);
				let currentSliceIndex = Math.floor(relativeAngle / arc);
				currentSliceIndex = Math.min(currentSliceIndex, includedNames.length - 1);

				// If we've crossed into a new slice, deflect the arrow and play sound
				if (lastSliceIndex !== -1 && currentSliceIndex !== lastSliceIndex) {
					arrowDeflection = -0.3; // Deflect backwards (against wheel direction)
					const now = Date.now();
					if (now - lastTickTime >= 80) {
						const wheelTickClone = wheelTick.cloneNode();
						playSound(wheelTickClone);
						wheelTickClone.addEventListener("ended", () => wheelTickClone.remove());
						lastTickTime = now;
					}
				}
				lastSliceIndex = currentSliceIndex;
			}

			// Gradually return arrow to normal position with spring-like motion
			if (arrowDeflection !== 0) {
				arrowDeflection *= 0.85;
				if (Math.abs(arrowDeflection) < 0.01) {
					arrowDeflection = 0;
				}
			}
		}
	}

	// Handle confetti animation when active
	if (confettiActive) {
		if (confettiSpawnTime < 3000) { // Spawn new confetti pieces over time
			const spawnCount = Math.floor(Math.random() * 5) + 8;
			for (let i = 0; i < spawnCount; i++) {
				confetti.push({
					x: Math.random() * canvas.width,
					y: -50,
					vx: (Math.random() - 0.5) * 4,
					vy: Math.random() * 2 + 1,
					color: confettiColors[Math.floor(Math.random() * confettiColors.length)],
					size: Math.random() * 12 + 8,
					rotation: Math.random() * 360,
					rotationSpeed: (Math.random() - 0.5) * 10
				});
			}
		}

		confetti.forEach(piece => {
			piece.x += piece.vx;
			piece.y += piece.vy;
			piece.vy += 0.05;
			piece.rotation += piece.rotationSpeed;
		});

		confetti = confetti.filter(piece => piece.y < canvas.height + 50); // Remove confetti that has fallen off screen

		if (confetti.length === 0 && confettiActive && activeSounds.size === 0) {
			confettiActive = false;
			if (mediaRecorder.state === "recording") {
				mediaRecorder.stop();
			}
		}

		confettiSpawnTime += 16; // Approximate frame time
	}

	// Draw everything to canvas
	const includedNames = names.filter(n => nameIncluded[n]);
	const arc = (Math.PI*2)/Math.max(1, includedNames.length);
	ctx.clearRect(0, 0, canvas.width, canvas.height);
	ctx.fillStyle = "white";
	ctx.fillRect(0, 0, canvas.width, canvas.height);
	ctx.font = "16px Arial";

	// Draw wheel segments
	includedNames.forEach((n,i) => {
		const angle = wheelAngle + i*arc;
		const isWinner = winningIndex !== null && names[winningIndex] === n;
		ctx.fillStyle = isWinner ? "white" : nameColors[n];
		ctx.beginPath();
		ctx.moveTo(canvasCenterX, canvasCenterY);
		ctx.arc(canvasCenterX, canvasCenterY, wheelRadius, angle, angle + arc, false);
		ctx.lineTo(canvasCenterX, canvasCenterY);
		ctx.fill();

		ctx.lineWidth = isWinner ? 8 : 2; // highlight winning segment
		ctx.strokeStyle = "black";
		ctx.stroke();

		ctx.save();
		ctx.translate(canvasCenterX, canvasCenterY);
		ctx.rotate(angle + arc/2);
		ctx.textAlign = "right";
		ctx.textBaseline = "middle";
		ctx.fillStyle = "black";
		ctx.fillText(n, wheelRadius - 10, 0);
		ctx.restore();
	});

	// Draw spin button
	const isDisabled = spinning || confettiActive;
	ctx.beginPath();
	ctx.arc(canvasCenterX, canvasCenterY, spinButtonRadius, 0, Math.PI*2);
	ctx.fillStyle = isDisabled ? "#cccccc" : "white";
	ctx.fill();
	ctx.strokeStyle = "black";
	ctx.lineWidth = 3;
	ctx.stroke();
	ctx.fillStyle = isDisabled ? "#666666" : "black";
	ctx.font = "bold 14px Arial";
	ctx.textAlign = "center";
	ctx.textBaseline = "middle";
	ctx.fillText((spinning || confettiActive) ? "Spinning..." : "SPIN", canvasCenterX, canvasCenterY);

	// Draw arrow at 3 o'clock (right side) pointing inward with deflection
	ctx.save();
	ctx.translate(canvasCenterX + wheelRadius + 15, canvasCenterY);
	ctx.rotate(arrowDeflection);
	ctx.translate(-15, 0);
	ctx.fillStyle = "white";
	ctx.strokeStyle = "black";
	ctx.lineWidth = 2;
	ctx.beginPath();
	const arrowLength = 30;
	ctx.moveTo(15, -5);
	ctx.lineTo(15, 5);
	ctx.lineTo(-15, 0);
	ctx.closePath();
	ctx.fill();
	ctx.stroke();
	ctx.restore();

	// Draw confetti effects if active
	if (confettiActive) {
		const time = Date.now() * 0.001;

		// Left spotlight - with waving motion and color cycling
		const leftHue = (time * 60) % 360;
		const leftWaveAngle = Math.sin(time * 3) * 0.6;
		const leftGradient = ctx.createRadialGradient( 0, canvas.height, 0, 0, canvas.height, Math.max(canvas.width, canvas.height) * 0.9);
		leftGradient.addColorStop(0, `hsla(${leftHue}, 80%, 70%, ${0.7 + 0.3 * Math.sin(time * 2)})`);
		leftGradient.addColorStop(0.15, `hsla(${leftHue}, 80%, 70%, ${0.5 + 0.2 * Math.sin(time * 2)})`);
		leftGradient.addColorStop(0.4, `hsla(${leftHue}, 80%, 70%, ${0.25 + 0.15 * Math.sin(time * 2)})`);
		leftGradient.addColorStop(0.7, `hsla(${leftHue}, 80%, 70%, ${0.1 + 0.05 * Math.sin(time * 2)})`);
		leftGradient.addColorStop(1, `hsla(${leftHue}, 80%, 70%, 0)`);

		ctx.save();
		ctx.fillStyle = leftGradient;
		ctx.beginPath();
		ctx.moveTo(canvas.width * 0.02, canvas.height);
		ctx.lineTo(canvas.width * 0.08, canvas.height);
		const leftTopX1 = canvas.width * (0.2 + leftWaveAngle * 0.6);
		const leftTopX2 = canvas.width * (0.8 + leftWaveAngle * 0.6);
		ctx.lineTo(leftTopX2, 0);
		ctx.lineTo(leftTopX1, 0);
		ctx.closePath();
		ctx.fill();
		ctx.restore();

		// Right spotlight - with waving motion (opposite phase) and color cycling
		const rightHue = (time * 60 + 180) % 360;
		const rightWaveAngle = Math.sin(time * 3 + Math.PI) * 0.6;
		const rightGradient = ctx.createRadialGradient(canvas.width, canvas.height, 0, canvas.width, canvas.height, Math.max(canvas.width, canvas.height) * 0.9);
		rightGradient.addColorStop(0, `hsla(${rightHue}, 80%, 70%, ${0.7 + 0.3 * Math.sin(time * 2.3)})`);
		rightGradient.addColorStop(0.15, `hsla(${rightHue}, 80%, 70%, ${0.5 + 0.2 * Math.sin(time * 2.3)})`);
		rightGradient.addColorStop(0.4, `hsla(${rightHue}, 80%, 70%, ${0.25 + 0.15 * Math.sin(time * 2.3)})`);
		rightGradient.addColorStop(0.7, `hsla(${rightHue}, 80%, 70%, ${0.1 + 0.05 * Math.sin(time * 2.3)})`);
		rightGradient.addColorStop(1, `hsla(${rightHue}, 80%, 70%, 0)`);

		ctx.save();
		ctx.fillStyle = rightGradient;
		ctx.beginPath();
		ctx.moveTo(canvas.width * 0.92, canvas.height);
		ctx.lineTo(canvas.width * 0.98, canvas.height);
		const rightTopX1 = canvas.width * (0.2 + rightWaveAngle * 0.6);
		const rightTopX2 = canvas.width * (0.8 + rightWaveAngle * 0.6);
		ctx.lineTo(rightTopX2, 0);
		ctx.lineTo(rightTopX1, 0);
		ctx.closePath();
		ctx.fill();
		ctx.restore();

		confetti.forEach(piece => { // draw confetti
			ctx.save();
			ctx.translate(piece.x, piece.y);
			ctx.rotate(piece.rotation * Math.PI / 180);
			ctx.fillStyle = piece.color;
			ctx.fillRect(-piece.size/2, -piece.size/2, piece.size, piece.size);
			ctx.restore();
		});
	}

	// Continue animation loop if spinning or confetti is active
	if (spinning || confettiActive) {
		requestAnimationFrame(drawCanvas);
	}
}

canvas.addEventListener("mousemove", e => { // check if user is hovering over the spin button
	const rect = canvas.getBoundingClientRect();
	const x = e.clientX - rect.left - canvasCenterX;
	const y = e.clientY - rect.top - canvasCenterY;
	const isOverButton = Math.sqrt(x*x + y*y) <= spinButtonRadius;
	canvas.style.cursor = (isOverButton && !spinning && !confettiActive) ? "pointer" : "default";
});

canvas.addEventListener("click", e => { // check if spin button was clicked
	const rect = canvas.getBoundingClientRect();
	const x = e.clientX - rect.left-canvasCenterX;
	const y = e.clientY - rect.top-canvasCenterY;
	if (Math.sqrt(x*x + y*y) <= spinButtonRadius) {
		const includedNames = names.filter(n => nameIncluded[n]);
		if (spinning || confettiActive || includedNames.length < 2) return;
		audioCtx.resume();
		setNameControlsDisabled(true);
		winningIndex = null;
		arrowDeflection = 0;
		lastSliceIndex = -1;
		spinning = true;
		wheelSpeed = Math.random()*0.8+0.4;
		wheelFriction = 0.988 + (Math.random() - 0.6) * 0.01;
		document.getElementById("download-btn").disabled = true;
		if (mediaRecorder.state !== "recording") {
			recordedChunks = [];   // reset buffer
			mediaRecorder.start();
		}
		isRecording = true;
		drawCanvas();
	};
});

names.forEach(n => nameIncluded[n] = true);
for (let i = names.length - 1; i > 0; i--) { // shuffle names to ensure fairness
	const j = Math.floor(Math.random() * (i + 1));
	[names[i], names[j]] = [names[j], names[i]];
}

// add toggle buttons for each name
document.getElementById("name-list").innerHTML = "";
sortedNames.forEach(n => {
	const item = document.createElement("span");
	item.className = "name-item";
	if (!nameIncluded[n]) item.classList.add("excluded");
	item.textContent = n;
	item.onclick = () => {
		if (!spinning && !confettiActive) {
			nameIncluded[n] = !nameIncluded[n];
			item.classList.toggle("excluded", !nameIncluded[n]);
			recomputeColors();
			winningIndex = null;
			drawCanvas();
		}
	};
	document.getElementById("name-list").appendChild(item);
});

// setup recording
const videoStream = canvas.captureStream(60);
const audioStream = audioDestination.stream;
const combinedStream = new MediaStream([...videoStream.getTracks(), ...audioStream.getTracks()]);
mediaRecorder = new MediaRecorder(combinedStream, {mimeType: 'video/webm;codecs=vp9,opus'});
mediaRecorder.ondataavailable = (event) => {
	if (event.data.size > 0) {
		recordedChunks.push(event.data);
	}
};
mediaRecorder.onstop = () => {
	const blob = new Blob(recordedChunks, { type: 'video/webm' });
	const url = URL.createObjectURL(blob);
	const today = new Date();
	const year = today.getFullYear();
	const month = String(today.getMonth() + 1).padStart(2, '0');
	const day = String(today.getDate()).padStart(2, '0');
	const filename = `Sporcle of the Day Selector ${year}-${month}-${day}.webm`;

	document.getElementById("download-btn").onclick = () => {
		const a = document.createElement('a');
		a.href = url;
		a.download = filename;
		document.body.appendChild(a);
		a.click();
		document.body.removeChild(a);
	};
	document.getElementById("download-btn").disabled = false;
	isRecording = false;
	setNameControlsDisabled(false);
};

recomputeColors();
drawCanvas();
</script>
</body>
</html>
